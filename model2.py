# -*- coding: utf-8 -*-
"""Model2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qIni4t_tWwmBUtG6TWLGNT0QOvvoDX1I
"""

!pip install pathway bokeh --quiet

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import pathway as pw
import bokeh.plotting
import panel as pn

# Install gdown to download files from Google Drive
!pip install gdown --quiet

# Extracted file ID from your Google Drive link
file_id = '1RqHF3zphAFOtYZgReDJUxEFweOiVAxqP'
output_path = 'your_dataset.csv'  # You can rename this

# Download the file from Google Drive
!gdown --id {file_id} -O {output_path} --quiet

# Load the CSV into a pandas DataFrame
import pandas as pd
df = pd.read_csv(output_path)

# Combine the 'LastUpdatedDate' and 'LastUpdatedTime' columns into a single datetime column
df['Timestamp'] = pd.to_datetime(df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'],
                                  format='%d-%m-%Y %H:%M:%S')

# Make sure Timestamp is datetime type
df['Timestamp'] = pd.to_datetime(df['Timestamp'])

# Sort first by Timestamp, then by SystemCodeNumber (parking location ID)
df = df.sort_values(by=['Timestamp', 'SystemCodeNumber']).reset_index(drop=True)

# Combine 'Latitude' and 'Longitude' into a single 'Location' column
df['Location'] = df['Latitude'].astype(str) + ' ' + df['Longitude'].astype(str)

print(len(df['SystemCodeNumber'].unique()))

print(df['Location'].unique())
print(df['TrafficConditionNearby'].unique())
print(df['VehicleType'].unique())

print(df['QueueLength'].unique())

print(df["IsSpecialDay"].dtype)

@pw.udf
def encode_location(loc: str) -> int:
    mapping = {
        '26.14453614 91.73617216': 1,
        '26.14449459 91.73620513': 2,
        '26.14901995 91.7395035': 3,
        '20.0000347 78.00000286': 4,
        '26.14001386 91.73099967': 5,
        '26.14004753 91.73097233': 6,
        '26.13795775 91.74099445': 7,
        '26.14747299 91.72804914': 8,
        '26.14754061 91.72797041': 9,
        '26.14749943 91.72800489': 10,
        '26.14749053 91.72799688': 11,
        '26.14754886 91.72799519': 12,
        '26.14749998 91.72797778': 13,
        '26.15050395 91.73353109': 14,
    }
    return mapping.get(loc, 0)

@pw.udf
def encode_vehicle_type(v) -> int:
    mapping = {'cycle': 1, 'bike': 2, 'car': 3, 'truck': 4}
    return mapping.get(v, 0)

@pw.udf
def encode_traffic(t) -> int:
    mapping = {'low': 1, 'average': 2, 'high': 3}
    return mapping.get(t, 0)

df_small = df[["Timestamp", "Occupancy", "Capacity", "Location", "QueueLength", "TrafficConditionNearby", "IsSpecialDay", "VehicleType"]]

df_small.to_csv("parking_stream_small.csv", index=False)

class ParkingSchema(pw.Schema):
    Timestamp: str
    Occupancy: int
    Capacity: int
    Location: str
    QueueLength: int
    TrafficConditionNearby: str
    IsSpecialDay: int
    VehicleType: str

data = pw.demo.replay_csv("parking_stream_small.csv", schema=ParkingSchema, input_rate=1000)

data = data.with_columns(
    EncodedLocation = encode_location(data.Location),
    EncodedTraffic = encode_traffic(data.TrafficConditionNearby),
    EncodedVehicle = encode_vehicle_type(data.VehicleType),
)

data = data.select(
    data.Timestamp,
    data.Occupancy,
    data.Capacity,
    data.QueueLength,
    data.IsSpecialDay,
    data.EncodedLocation,
    data.EncodedTraffic,
    data.EncodedVehicle,
)

# Define the datetime format to parse the 'Timestamp' column
fmt = "%Y-%m-%d %H:%M:%S"

# Add new columns to the data stream:
# - 't' contains the parsed full datetime
# - 'day' extracts the date part and resets the time to midnight (useful for day-level aggregations)
data_with_time = data.with_columns(
    Time = data.Timestamp.dt.strptime(fmt),
    day = data.Timestamp.dt.strptime(fmt).dt.strftime("%Y-%m-%dT00:00:00")
)

demand = data_with_time.windowby(
    pw.this.Time,
    window=pw.temporal.tumbling(datetime.timedelta(minutes=30)),
    instance=pw.this.EncodedLocation,
    behavior=pw.temporal.exactly_once_behavior()
).reduce(
    Time = pw.this._pw_window_end,
    Location = pw.this._pw_instance,
    Occupancy_sum = pw.reducers.sum(pw.this.Occupancy),
    Capacity_sum = pw.reducers.sum(pw.this.Capacity),
    Queue_sum = pw.reducers.sum(pw.this.QueueLength),
    Traffic_sum = pw.reducers.sum(pw.this.EncodedTraffic),
    SpecialDay_sum = pw.reducers.sum(pw.this.IsSpecialDay),
    Vehicle_sum = pw.reducers.sum(pw.this.EncodedVehicle),
    Count = pw.reducers.count(),
).with_columns(
    Occupancy = pw.this.Occupancy_sum / pw.this.Count,
    Capacity = pw.this.Capacity_sum / pw.this.Count,
    QueueLength = pw.this.Queue_sum / pw.this.Count,
    TrafficCondition = pw.this.Traffic_sum / pw.this.Count,
    IsSpecialDay = pw.this.SpecialDay_sum / pw.this.Count,
    VehicleType = pw.this.Vehicle_sum / pw.this.Count,
).with_columns(
    NormalDemand = 5 * (pw.this.Occupancy / pw.this.Capacity)
                 + (3/20)*pw.this.QueueLength
                 + (1/6)*pw.this.TrafficCondition
                 + (1/2)*pw.this.IsSpecialDay
                 + (1/4)*pw.this.VehicleType
)

result = demand.with_columns(
    Price = 10 * (1 + (1/10) * pw.this.NormalDemand)
).select(
    pw.this.Time,
    pw.this.Location,
    pw.this.Price
)

pw.debug.compute_and_print(result)

import io
import sys
import pandas as pd

# Capture the printed output
buffer = io.StringIO()
sys.stdout = buffer

pw.debug.compute_and_print(result)  # triggers run
sys.stdout = sys.__stdout__         # reset stdout

# Parse the output
raw_output = buffer.getvalue().strip().split("\n")
rows = [line.split("|") for line in raw_output if "|" in line]
columns = [col.strip() for col in rows[0]]
data = [[val.strip() for val in row] for row in rows[1:]]

# Convert to DataFrame
df = pd.DataFrame(data, columns=columns)

# Fix data types
df["Time"] = pd.to_datetime(df["Time"])
df["Location"] = df["Location"].astype(int)
df["Price"] = df["Price"].astype(float)

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource, HoverTool
from bokeh.palettes import Category20_20
from bokeh.layouts import column

output_notebook()

p = figure(x_axis_type="datetime", title="Price per Parking Space", width=1000, height=500)
p.xaxis.axis_label = 'Time'
p.yaxis.axis_label = 'Price'

colors = Category20_20 * 2  # Up to 40 lines

for i, space in enumerate(sorted(df["Location"].unique())):
    df_space = df[df["Location"] == space]
    source = ColumnDataSource(df_space)
    p.line(x='Time', y='Price', source=source, legend_label=f"Space {space}", line_width=2, color=colors[i % len(colors)])

p.legend.title = "Parking Space"
p.legend.location = "top_left"
p.legend.label_text_font_size = "8pt"

p.add_tools(HoverTool(
    tooltips=[("Time", "@Time{%F %T}"), ("Price", "@Price"), ("Space", "@Location")],
    formatters={"@Time": "datetime"},
    mode='mouse'
))

show(p)